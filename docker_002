该学习笔记 根据 http://www.cnblogs.com/CloudMan6/p/6693772.html 记录自身认为的知识点
感谢 CloudMan 提供的原创《每天5分钟玩转OpenStack》教程

What - 什么是容器？
	容器是一种轻量级、可移植、自包含的软件打包技术，是应用程序可以在几乎任何地方以相同的方式运行。

容器与虚拟机
	容器组成
		应用程序本身
		依赖：比如应用程序需要的库或其他软件

容器在Host 操作系统的用户空间中运行，与操作系统其他进程隔离
传统的虚拟化技术，比如VMWare,KVM,Xen,目标是创建完整的虚拟机，为了运行应用，除了部署应用本身及其依赖，还得安装整个操作系统


Why - 为什么需要容器？
	容器使如软件具备了超强的可移植能力


Docker 的特性
我们可以看看集装箱思想是如何与 Docker 各种特性相对应的。

特性	     集装箱	             Docker
打包对象	几乎任何货物			任何软件及其依赖
硬件依赖	标准形状和接口允许集装箱被装卸到各种交通工具，整个运输过程无需打开			容器无需修改便可运行在几乎所有的平台上 -- 虚拟机、物理机、公有云、私有云
隔离性	    集装箱可以重叠起来一起运输，香蕉再也不会被铁桶压烂了			资源、网络、库都是隔离的，不会出现依赖问题
自动化	    标准接口使集装箱很容易自动装卸和移动			提供 run, start, stop 等标准化操作，非常适合自动化
高效性	    无需开箱，可在各种交通工具间快速搬运			轻量级，能够快速启动和迁移
职责分工	货主只需考虑把什么放到集装箱里；承运方只需关心怎样运输集装箱			开发人员只需考虑怎么写代码；运维人员只需关心如何配置基础环境



How - 容器是如何工作的？

Docker 采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。

运行一个 http容器
	1.Docker 客户端执行 docker run 命令
	2.Docker daemon 发现本地没有httpd镜像
	3.daemon从Docker Hub下载镜像
	4.下载完成，镜像httpd被保存到本地
	5.Docker daemon启动容器


镜像是Docker 容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。
	
	镜像的内部结构
		Dockerfile 是镜像的描述文件，定义了如何构建Docker镜像.Dockerfile的语法简洁且可读性强
			hello-world 的 Dockerfile内容如下：
			FROM scratch
			COPY hello /
			CMD ["/hello"]
	只有短短三条指令
		1.FROM scratch
			此镜像是从白手起家，从0开始构建
		2.COPY hello /
			将文件"hello"复制到镜像的根目录
		3.CMD ["/hello"]
			容器启动时，执行/hello


	base 镜像
		1.不依赖其它镜像，从scratch构建
		2.其它镜像可以以它为基础进行扩展
	故能称为base镜像的通常都是各种Linux发行版的Docker镜像，比如Ubuntu,Debian,Centos等

		rootfs
			内核空间是kernel,Linux 刚启动时会加载bootfs文件系统，之后bootfs会被卸载掉
			用户空间的文件系统是rootfs，包含我们熟悉的/dev,/proc,/bin等目录
			对于base镜像来说，底层直接使用Host的kernel，自己只需要提供rootfs就行了。

		CentOS镜像的Dockerfile的内容
			FROM scratch
			ADD centos-7-docker.tar.xz /
			CMD ["/bin/bash"]

		支持运行多种Linux OS
			不同Linux发行版的区别主要就是rootfs.
				1.base镜像只是在用户空间与发行版一致,kernel版本与发行版是不同的
				2.容器只能使用Host的kernel,并且不能修改

	镜像的分层结构

		Docker 支持通过扩展现有镜像，创建新的镜像
		构建新镜像
			FROM debian
			RUN apt-get install emacs
			RUN apt-get install apache2
			CMD ["/bin/bash"]

			1.新镜像不是重scratch开始，而是直接在Debian base镜像上构建。
			2.安装emacs编辑器
			3.安装apache2
			4.容器启动时运行bash
		新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层

		好处 ----> 共享资源

		可写的容器层（Copy-on-Write特性）
			容器启动时，一个新的可写层被加载到镜像的顶部，该层通常叫 "容器层"，"容器层"之下都叫"镜像层"

			只有容器层是可写的，容器层下面的所有镜像层都是只读的。

	构建镜像
		Docker 提供了两种构建镜像的方法：
			1.docker commit命令（不建议使用）
				1.运行容器
				2.修改容器
				3.将容器保存为新的镜像

			2.Dockerfile 构建文件
				dockerfile 文件
				docker build 命令
				docker history 命令 显示镜像的构建历史
	镜像的缓存特性
		Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无需重新创建
		如果我们希望在构建镜像时不使用缓存，可以在docker build 命令中加上 --no-cache 参数
		Dockerfile中每一个指令都会创建一个镜像层，上层是依赖于下层的。只要某一层发生变化，其上层所有缓存都会失效

	调试Dockerfile
		Dockerfile构建镜像的过程：
			1.从base镜像运行一个容器
			2.执行一条指令，对容器做修改
			3.执行类似docker commit的操作，生成一个新的镜像层。
			4.Docker再基于刚刚提交的镜像运行一个新容器。
			5.重复2-4步，直到Dockerfile中所有指令执行完毕。

	Dockerfile 常用指令

		FROM 
			指定base镜像
		MAINTAINER
			设置镜像作者
		COPY
			将文件从build context复制到镜像
			COPY src dest
			COPY ["src","dest"]
		ADD
			与COPY类似，如果是归档文件，文件会自动解压到dest
		ENV
			设置环境变量，可以被后面的指令使用
		EXPOSE
			指定容器中的进程会监听某个端口
		WOLUME
			将文件或目录声明为volume
		WORKDIR
			设置镜像中的当前工作目录
		RUN
			在容器中运行指定的命令
		CMD
			容器启动时运行指定的命令
		ENTERPOINT
			设置容器启动时运行的命令

	RUN vs CMD vs ENTERYPOINT
		1.RUN执行命令并创建新的镜像层，RUN经常用于安装软件包
		2.CMD设置容器启动后默认执行的命令及参数，但CMD能够被docker rum后面跟的命令行参数替换
		3.ENTERYPOINT 配置容器启动时运行的命令

	镜像命名的最佳实践

		如何在多个Docker Host上使用镜像
			1.用相同的Dockerfile在其他host构建惊险
			2.将镜像上传到公共的Registry(比如 Docker Hub),Host直接下载使用
			3.搭建私有的Registry供本地Host使用

		特定镜像的名称由两部分组成：repository 和 tag
			[image name] = [repository]:[tag]
			没有指定tag，会使用默认值latest

	使用公共Registry

	创建自己的Registry


	Docker 镜像小结
		镜像的常用操作子命令
			images 显示镜像列表
			history 显示镜像构建历史
			commit 从容器创建新镜像
			build 从Dockerfile构建镜像
			tag 给镜像打tag
			pull 从registry下载镜像
			push 将镜像上传到registry
			rmi 删除Docker host中的镜像
			search 搜索Docker Hub 中的镜像

		rmi 只能删除host删的镜像，不会删除registry的镜像，如果一个镜像对应多个tag,只有最后一个tag被删除时，镜像才被真正删除。

		search 在命令行中搜索Docker Hub中的镜像