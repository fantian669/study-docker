	在测试中使用Docker
	
	 在实际开发和测试过程中使用Docker.首先看看Docker如何使用开发和测试更加流程化,效率更高.
	
		使用Docker测试一个静态网站
		使用Docker创建并测试一个Web应用
		将Docker用于持续集成
	
	1.使用Docker测试静态网站
将Docker作为本地开发环境是使用Docker的一个最简单的场景.这个环境可以完全重现生产环境,保证开发环境和部署环境一致.下面将Nginx安装到容器来架构yiuge简单的网站开始.这个网站暂时命名为Sample.
	
	mkdir sample             
	cd sample
	touch Dockerfile  ===>为Nginx Dockerfile创建一个目录
现在还需要一些Nginx配置文件,才能运行这个网站,首先在这个示例所在的目录里创建以个名为nginx的目录,用来存放配置文件,如后可以下载示例文件.
	cd sample
	mkdir nginx && cd nginx
	wget 	https://raw.githubusercontent.com/jamtur01/dockerbook-code/master/code/5/sample/nginx/global.conf
	wget 	https://raw.githubusercontent.com/jamtur01/dockerbook-code/master/code/5/sample/nginx/nginx.conf
	cd ..

	
	FROM ubuntu
	MAINTAINER rnjack "rnjack998@gmail.com"
	ENV REFRESHED_AT  2016-10-22
	RUN apt-get update
	RUN apt-get -y -q install nginx
	RUN mkdir -p /var/www/html
	ADD nginx/global.conf     /etc/nginx/conf.d/
	ADD nginx/nginx.conf     /etc/nginx/nginx.conf
	EXPOSE 80                                                  ====>网站测试的基本Dockerfile

	Dockerfile内容包括以下几项:
		安装Nginx
		在容器中创建一个目录/var/www/html
		将来自我们下载的本地文件的Nginx配置文件添加到镜像中.
		公开镜像的80端口

	这个Nginx配置文件是为了运行Sample网站而配置的.将文件nginx/global.conf用ADD指令复制到/etc/nginx/conf.d目录中.
	这个文件将Nginx设置为监听80端口,并将网络服务的根路径设置为/var/www/html/website 这个目录是我们用RUN指令创建的.
	需要将Nginx配置为非守护进程的模式.这样可以让Nginx在Docker容器里工作,将文件nginx/nginx.conf 复制到/etc/nginx目录就可以达到这个目的在nginx.conf中设置daemon off;选项阻止Nginx进入后台,强制其在前台运行.这是因为要想保持Docker容器的活跃状态,需要其中运行的进程不能中断.默认情况下,Nginx会以守护进程的方式启动,这会导致容器只是短暂运行,在守护进程被fork启动后,发起守护进程的原始进程就会退出,这时容器就会停止运行

	
	构建Sample网站和Nginx镜像
	
	利用之前的Dockerfile,可以用docker build命令构建出新的镜像,并将这个镜像为rnjack/nginx
		docker build -t rnjack/nginx	 ===>构建新的Nginx镜像

	使用docker histroy 命令查看构建镜像的步骤和层级
		docker histroy rnjack/nginx      ===>展示Nginx镜像的构建历史
history命令从新构建的rnjack/nginx镜像的最后一层开始,追溯到最开始的父镜像ubuntu:14.04.这个命令也展示了每步之间创建的新层,以及创建这个层所使用的Dockerfile里的指令.


	从Sample网站和Nginx镜像构建容器
	
现在可以使用rnjack/nginx镜像,并开始从这个镜像构建可以用来测试Sample网站的容器.首先,需要一个被测试的Sample网站.下载一些代码来创建网站
	cd sample             ===>下载Sample网站
	mkdir website && cd website
	wget https://raw.githubusercontent.com/jamtur01/docker-code/master/code/5/sample/website/index.html
	cd ..	


	构建第一个Nginx测试容器
		docker run -d -p 80 --name website -v $PWD/website:/var/www/html/website rnjack/nginx nginx
我们使用docker run命令从rnjack/nginx镜像创建了一个名为website的容器. -v这个选项允许我们将宿主机的目录作为卷,挂载到容器里. 卷在Docker里非常中重要,也很有用. 卷是在一个或多个容器内被选定的目录.可以绕过分层的联合文件系统(Union File System),为Docker提供持久数据或者共享数据.这意味着对卷的修改会直接生效,并绕过镜像.当提交或者创建镜像时,卷不被包含在镜像里. 卷可以在容器间共享.即便容器停止,卷的内容依旧存在.当我们因为某些原因不想把应用或者代码构建到镜像中时.就体现卷的价值了.
		
	希望同时对代码做开发和测试
	代码改动很频繁,不想在开发过程中重构镜像
	希望在多个容器间共享代码
  参数 -v指定了卷的源目录(本地宿主机的目录)和容器里的目的目录,这两个目录通过:来分离.如果目的目录不存在,Docker会自动创建一个,也可以通过在目录后面加上 rw 或者 ro 来指定目的的目录的读写状态

	docker run -d -p 80 --name website -v $PWD/website:/var/www/html/website:ro rnjack/nginx nginx
  这将使目的的目录/var/www/html/website变成只读状态.在Nginx网站的容器里,我们通过卷将$PWD/website 挂载到容器的/var/www/html/website目录,顺利挂载了正在开发的本地网站.在Nginx配置里(在配置文件/etc/nginx/conf.d/global.conf中)已经指定了这个目录为Nginx服务器的工作目录.
	docker ps -l  ===>查看Sample网站容器
  如果在Docker 的宿主机上浏览器32768端口, 直接在浏览器中输入 http://localhost:32769就会看见网站页面
	
	修改网站
  修改网站,直接打开本地宿主机的website目录霞的index.html文件并修改,修改完成,再次访问该链接,网站的内容修改完成.更改复杂的修改也并不困难,更重要的是,正在测试网站的运行环境,完全是生产环境的真实状态.现在可以给每个用于生产的网站服务环境(如 Apache Nginx)配置一个容器,给不同开发框架的运行环境(如 PHP 或者 Ruby on Rails)配置一个容器,或者给后端数据库配置一个容器,等等.



	2.使用Docker构建并测试web应用程序

  测试一个更大的Web应用程序.测试一个基于Sinatra的Web应用程序,而不是静态网站.下面的例子会演示如何在Docker里开发并测试应用程序.这个应用程序会接收输入参数,并使用JSON散列输出这些参数.
	
	2.1构建Sinatra应用程序
   构建基础镜像,并用这个镜像来开发Sinatra Web应用,测试用Web应用程序的Dockerfile
	FROM ubuntu
	MAINTAINER rnjack "rnjack998@gmail.com"
	ENV REFRESHED_AT 2016-10-23

	RUN apt-get update
	RUN apt-get -y install ruby ruby-dev build-essential redis-tools
	RUN gem install --no-rdoc --no-ri sinatra json redis
	
	RUN mkdir -p /opt/webapp
	
	EXPOSE 4567
	
	CMD ["/opt/webapp/bin/webapp"]	

    我们创建另一个基于Ubuntu的镜像,安装Ruby 和RubyGem,并且使用gem命令安装sinatra json 和 redis包,然后还创建一个目录来存放新的Web应用程序并公开可WEBrick的默认端口4567
   最后,使用 CMD指定/opt/webapp/bin/webapp作为Web应用程序的启动文件    

	docker build -t rnjack/sinatra     ===>构建新的Sinatra镜像

	2.2创建Sinatra容器
	
   下载Sinatra Web应用程序的源代码,这应用程序在webapp目录下,由bin和lib两个目录组成

	wget --cut-dirs=3 -nH -r --no-parent http://dockerbook.com/code/5/sinatra/webapp/

	ls -l webapp
   使用chmod 命令保证webapp/bin/webapp文件可以执行
	chmod +x $PWD/webapp/bin/webapp                 ===>确保webapp/bin/webapp可以执行	

	
	启动第一Sinatra容器

	docker run -d -p 4657 --name webapp -v $PWD/webapp:/opt/webapp rnjack/sinatra
    这里从rnjack/sinatra镜像创建一个新的名为webapp的容器.指定一个新卷$PWD/webapp,来存放新的Sinatra Web应用程序,并将这个卷挂载到Dockfile里创建的目录/opt/webapp. 我们没有在命令行中提供要运行的命令,而是在镜像的Dockfile里的CMD指令中提供这一命令

	docker logs webapp           	===>检查Sinatra的日志
   运行docker logs 命令时加上-f 标志可以达到与执行tail -f 命令一样的效果  持续输出容器的STDERR和 STDOUT里的内容.
	docker logs -f webapp           ===>跟踪Sinatra容器的日志
	
	docker top webapp               ===>使用docker top 来列出Sinatra进程

	docker port webapp              ===>检查Sinatra的端口映射

   目前,Sinatra应用还很基础,它只是接收输入参数,并将输入参数转化为JSON输出,下载可以使用curl命令开测试这个应用程序 测试Sinatra应用程序
	curl -i -H 'Accept: application/json' -d 'name=RNjack&status=Bar' http://localhost:32771 

	
	构建Redis镜像和容器

    我们将要扩展Sinatra应用程序,加入Redis后端数据库,并在Redis数据中存储输入的参数.为了达到这个目的,要构建全新的镜像和容器来运行Redis数据库.之后,要利用Docker的特性来关联两个容器.
   
    为了构建Redis数据库,要创建一个新的镜像.从一个新的Dockerfile开始,逐步让Redis运行在Docker里.用于Redis镜像的Dockerfile

	FROM ubuntu:14.04
	MAINTAINNER rnjack 'rnjack998@gmail.com'
	ENV REFRESHED_AT 2016-10-24
	RUN apt-get update
	RUN apt-get -y install redis-server redis-tools
	EXPOSE 6379
	ENTRYPOINT ["/usr/bin/redis-server"]
	CMD []	
       
     我们在Dockerfile里指定了安装Redis服务器,公开6379端口,并指定了启动Redis服务器的ENTRYPOINT.现在来构建这个镜像,命名为rnjack/redis
	docker build -t rnjack/redis .    ===>构建Redis镜像

	docker run -d -p 6379 --name redis rnjack/redis     ===>启动Redis容器
  可以看到,我们从rnjack/redis镜像启动了一个新的容器,名字是redis.注意.我们指定了-p标志来公开6379端口,看看映射到宿主机的哪个端口.
	docker port redis 6379           ===>查看端口

  我们需要在本地安装Redis客户端做测试,客户端程序一般在redis-tools包里
	
	apt-get -y install redis-tools          ===>在Ubuntu上安装redis-tools包

	redis-cli -h 127.0.0.1 -p 49361         ===>测试连接到Redis服务器


	2.4 连接到Redis容器
   
    现在设置更新Sinatra应用程序,让其连接到Redis并存储传入的参数.为此,需要能够与Redis服务器对话,要做到这点,可以有以下几种方法.

    第一种方法:涉及Docker自己的网络栈.到目前为止,我们看到的Docker容器都是公开端口并绑定到本地网络接口的,这样可以把容器的服务在本地Docker宿主机所在的外部网络上(比如,把容器里的80端口绑到本地宿主机的更高端口上)公开.除了这种用法,Docker这个特性还有种方法我们没有见过,那是内部网络.

    在安装Docker时,会创建一个新的网络接口,名字是docker0.每个Docker容器都会在这个接口上分配一个IP地址.来看看目前Docker宿主机上这个接口的的信息.如下代码:
	ip a show docker0          ===>docker0网络接口
 
	4: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:df:83:d8:94 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:dfff:fe83:d894/64 scope link 
       valid_lft forever preferred_lft forever

   docker0接口有符合RFC1918私有IP地址,范围是172.16~172.30.接口本身的地址172.17.0.1是这个Docker网络的网关地址,也是所有Docker容器的网关地址. 提示:Docker会默认使用172.17.x.x作为子网地址,除非已经有别人占用了这个子网.如果这个子网被占用了.Docker会在172.16~172.30这个范围内尝试出创建子网.
   接口docker0是一个虚拟的以太网桥,用于连接容器和本地宿主网络.如果进一步查看Docker宿主机的其它网络接口,会发现一系列veth开头的接口

	vethb6926cc Link encap:以太网  硬件地址 7e:42:ab:5d:28:c6  
        inet6 地址: fe80::7c42:abff:fe5d:28c6/64 Scope:Link                    ===>veth接口

   Docker每创建一个容器就会创建一组互联网的网络接口.这组接口就像管高的两端(就是说,从一端发送的数据会在另一端收到).这组接口其中一端作为容器里的eh0接口,而另一端统一命名为类似vethb6926cc这种名字,作为宿主机的一个端口.可以报veth接口认为是虚拟网线的一端.这个虚拟网线的一端插在名为Docker0的网桥上,另一端插到容器里.通过报每个veth*接口绑定到docker0网桥,Docker创建了一个虚拟子网,这个子网由宿主机和所有的Docker容器共享.进入容器里面,看看这个子网管道的另一端

	docker run -t -i ubuntu /bin/bash              ===>容器内的eth0接口
	ip a show eth0

        可以看到,Docker给容器分配了IP地址172.17.0.13作为宿主机虚拟接口的另一端.这样就能让宿主网络和容器互相通信了.让我们从容器内跟踪对外通信的路由,看看如何建立连接的.
	
	apt-get install -yqq traceroute
	traceroute google.com
	
	可以看到容器地址后的下一跳是宿主机网络上docker0接口的网关IP 172.17.0.1.不过Docker网络还有另一部分配置才能允许建立连接:防火墙规则和NAT配置.这些配置允许Docker在宿主网络和容器间路由.查看宿主机上的IPTables NAT配置

	iptables -t  nat -L -n                 ===>Docker的iptables和NAT配置

Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         
DOCKER     all  --  0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL

Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
DOCKER     all  --  0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         
MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0           
MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:6379

Chain DOCKER (2 references)
target     prot opt source               destination         
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:32768 to:172.17.0.2:6379

	这里有几个地方值得注意的IPTables规则,首先,我们注意到,容器默认是无法访问的.从宿主网络与容器通信时,必须明确指定打开的端口.下面我们以DNAT(即目的NAT)这个规则为例,这个规则把容器里的访问路由到Docker宿主机的32768端口.


	2.5 连接Redis

    我们用docker inspect命令来查看新的Redis容器的网络配置.
	docker inspect redis       ===>Redis容器的网络配置

	docker inspect -f  '{{.NetworkSettings.IPAddress}}' redis   ===>查看Redis容器的IP地址
	172.12.0.2
   	
     可以看到,容器的IP地址为172.17.0.2,并使用了docker接口作为网关地址.还可以看到6379端口被映射到本地宿主机设为32768端口.只是,因为运行在本地的Docker宿主机上,所以不是一定要用映射端口,也可以使用171.17.0.2地址与Redis服务器的6379端口通信.

	redis-cli -h 172.17.0.2              ===>直接与Redis容器通信
    注意:Docker默认会把公开的端口绑定到所有的网络接口上.因此,也可以通过localhostt或者127.0.0.1来访问Redis服务器.

    虽然这看上去是让容器互联的一个好方案,但可惜的是,这种方法有两个问题:第一,要在应用程序里对Redis容器的IP地址做硬编码;第二.如果重启容器,Docker会改变容器的IP地址.现在用docker restart命令来看看地址变化:

	docker restart redis      ===>重启Redis容器

	docker inspect -f '{{.NetworkSetting.IPAddress}}' redis      ===>查找重启后Redis容器的IP地址
	
	这次可以看到,Redis容器有了新的IP地址.如果在Sinatra应用程序里硬编码了原来的地址,那么现在就没法让应用程序连接到Redis数据库.Docker有个叫做连接(link)的功能非常有用.这个功能可以把一个或者多个Docker容器连接起来,让其互相通信.


	2.6  让Docker容器互相连接

    让一个容器和另一个容器连接起来只需要一个简单的流程,这个流程要引用容器的名字.
		
	docker run -d  --name redis  rnjack/redis      ===>启动一个Redis容器
    注意:这里没有公开容器的任何端口.

	启动Web应用程序容器,并把它连接到新的Redis容器上去.
	
	docker run -p 4567 --name webapp --link redis:db -t -i -v $PWD/webapp":/opt/webapp  rnjack/sinatra /bin/bash      ===>连接Redis容器

   这个命令做了不少事情,首先我们使用-p标志公开了4567端口,这样就能从容器外面访问Web应用程序.
   使用--name标志给容器命名为webapp,并且使用了-v标志把Web应用程序作为卷挂载到容器里
   使用了一个新的标志--link,--link标志创建了两个容器的父子间连接,这个标志需要两个参数:一个是要连接的容器名字,另一个是连接后容器的别名.这个例子中,我们把新容器连接到redis容器,并使用db作为别名.别名让我们可以访问公开的信息,而无须关底层容器的容器.连接让父容器有能力访问子容器,并且把子容器的一些连接细节分享容器.这些细节有助于配置应用程序并使用这个连接.

  启动Redis容器时,并没有使用-p标志公开Redis端口,因为不需要这么做,通过把容器连接在一起,可以让父容器直接访问任意子容器的公开端口(比如,父容器webapp可以连接到子容器redis的6379端口).更妙的是,只用使用--link标志连接到这个容器的容器才能连接到这个端口.容器的端口不需要对本地宿主机公开.现在我们已经有一个非常安全的模型.通过这个安全模型,就可以限制容器化应用程序的攻击面,减少应用暴露的网络.

   我们可以把多个容器连接在一起,比如,如果想让这个Redis实例服务于多个Web应用程序可以把每个Web应用程序的容器和同一个redis容器连接在一起

	docker run -p 4657 --name webapp1 --link redis:db...

	docker run -p 4657 --name webapp2 --link redis:db...   ===>连接Redis容器

  被连接的容器必须运行在同一个Docker宿主机上.不同Docker宿主机上运行的容器无法连接.最后,让容器启动时加载shell,而不是服务守护进程,遮掩可以查看容器是如何连接在一起的.Docker在父容器里的以下的两个地方写入了连接信息:
	/etc/hosts文件中
	包含连接信息的环境变量中.

	cat /etc/hosts             ===>webapp的/etc/hosts文件
		172.17.0.33 811bd66d588db
		...
		172.17.0.2 db
	第一项是容器自己的IP地址和主机名(主机名是容器ID的一部分).第二项是由该连接指令创建的,它是redis容器的IP地址和从该连接的别名衍生的主机名db.尝试ping一下db容器.

	提示:容器的主机名也可以不是ID的一部分,可以在执行docker run命令时使用-h或者--hostname标志来为容器设定主机名.
	
	ping db                      ===>ping一下db容器

	env                         ===>显示用于连接的环境变量

	在这些环境变量中,其中有些以DB开头.Docker在连接webapp和redis容器时,自动创建了这些以DB开头的环境变量;以DB开头是因为DB创建连接时使用的别名 这些自动创建的环境变量包含以下信息
	子容器名字
	容器里运行的服务所使用的协议,IP和端口号
	容器里运行的不同服务所指定的协议,IP和端口号
	容器里由Docker设置的环境变量的值

这些环境变量会随着容器的不同而变化,取决与容器是如何配置的(如容器的Dockerfile里由ENv和EXPOSE指令定义的内容).更重要的是,这些连接信息可以让容器内的应用程序使用相同的方法与别的容器进行连接,而不用关心连接容器的具体细节

	2.7 使用容器连接来通信
     那么如何使用这个连接呢?给Sinatra应用程序加入一些连接信息,以便与Redis通信,有以下两种方法可以让应用程序连接到Redis.
	使用环境变量里的一些连接信息.
	使用DNS和/etc/hosts信息.
    Web用用程序的lib/app.rb文件是如何利用这些新的环境的变量

	require 'uri'
		...
	uri=URI.parse(ENV['DB_PORT'])
	redis=Redis.new(:host=>uri.host, :port=>uri.port)

    这里使用Ruby的URI模块来解析DB_PORT环境变量,并使用解析后的结果来配置Redis连接.应用程序现在可以使用这个连接信息找到相连的Redis容器.通过环境变量,这里不再需要硬编码的IP地址和端口来进行连接.这是一种发现服务的方法.
    另一种方法,可以使用本地DNS
	也可以在docker run 命令中加入--dns或者--dns-search标志来为某个容器单独配置DNS,可以设置本地DNS解析的路仅和搜索路线.如果没有这两个标志,Docker会根据宿主机的信息来配置DNS解析.可以在/etc/resolv.conf文件中查看DNS解析的配置情况.
	
	redis =  Redis.new(:host =>'db', :port=>'6379')	    ===>使用主机名连接Redis


















	

































	




























	















































	





































	






































































	





	






















































