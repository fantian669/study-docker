	使用Docker镜像和仓库

创建一个最基本的Docker容器
	docker run -i -t --name another_container  ubuntu /bin/bash 
这条命令将会启动一个新的名为anthor_container 的容器,这个容器基于ubuntu镜像并且会启动Bash shell.

本章中我们将探讨Docker镜像:用来启动容器的基石:学习内容  什么是镜像,如何对镜像进行管理,如何修改镜像,以及如何创建,存储和共享自己创建的镜像,还会介绍用来存储镜像的仓库和用来存储仓库的Registry.



1.什么是Docker镜像
	Docker镜像是由文件系统叠加而成的.最底端是一个引导文件系统,即bootfs,这很像典型的Linux/Unix的引导文件系统.Docker用户几乎永远不会和引导文件文件系统有什么交互,实际上当一个容器启动后,它就会被移动内存中,而引导文件系统则会被卸载(unmount).以留更多内存供initd磁盘镜像使用.

	Docker镜像的第二层是root文件系统rootfs,它位于引导文件系统之上.rootfs可以是一种或多种操作系统(如Debian或者Ubuntu文件系统)在传统的Linux引导过程中,root文件系统会最先以只读的方式加载,当引导结束并完成了完整性检查之后,才会被切换为读写模式 但是在Docker里,root文件系统永远是只读状态,并且Docker利用联合加载(union mount)技术又会在root文件系统层上加载更多的只读文件系统.联合加载指的是一次同时加载多个文件系统,但是在外面只能看到一个文件系统.联合加载会将各层文件系统叠加到一起,这样最终文件系统包含所有底层的文件和目录.

	Docker将这样的文件系统称为镜像,一个镜像可以放到另一个镜像的顶部,位于下面的镜像称为parent image ,最底部的镜像称为基础镜像 base image. 当从一个镜像启动时,Docker会在该镜像的顶层加载一个读写文件系统.


	可写容器
	
	镜像 :加入Apacher
	镜像 :加入emacs
	基础镜像: ubuntu
	引导文件系统
		容器组 命名空间 设备映射
	内核

写时复制(copy and write):初始对写层是空的,当文件系统发生变化是,这些变化都会应用到读写层,比如:想修改一个文件,这个文件爱呢首先会从该读写层虾米拿的只读层复写到该读写层.该文件的只读版本依然存在,但已经被读写层的文件副本所隐藏


当创建一个新的容器时,Docker会构建一个镜像栈,并在栈的最顶端添加一个读写层,这个对写层加上其下面的镜像层以及一些配置数据,就构成一个容器



2.列出镜像

	docker images  ===>列出Docker镜像

本地镜像都保存在Docker宿主机的/var/lib/docker目录霞.每个镜像都保存在Docker所采用的存储驱动目录下面如 aufs或者 devicemapper 也可以在/var/lib/docker/containers目录霞看到所有容器
镜像从仓库下载写来.镜像保存在仓库中,而仓库存在与Registry中,而默认的Registry是由Docker公司运行的公共Registry服务,即Docker Hub	

	docker pull ubuntu     ===>拉取Ubuntu镜像
	使用docker pull ubuntu命令拉取Ubuntu仓库中的所有内容
注意:我们虽然称其为Ubuntu操作系统,但实际上它并不是一个完整的操作系统,它只是一个裁剪版,只包含最低限度的支持系运行的组件,为了区分同一个仓库中的不同镜像,Docker提供了一种被称为标签(tag)的功能,每个镜像在列出时都带有一个标签.我们可以通过仓库名后面加一个冒号和标签名来指定该仓库的某以镜像

	docker run -i -t --name new_container ubuntu:12.04 /bin/bash  ==>运行一个带标签的Docker镜像  
这个例子会从镜像ubuntu:12.04启动一个容器,而这个镜像的操作系统则是ubuntu12.04.很多镜像具有相同的镜像ID,它们被打了很多标签.比如74fe38d11401的镜像被打上了12.04和precise两个标签,分别代表该Ubuntu发布版本号和代号(code name)

	在构建容器时指定仓库的标签也是一个很好的习惯.这样便可以准确来指定容器来源与哪里.不同的镜像会有不同,比如Ubuntu12.04和14.04j就不一样,指定镜像的标签会上我们确切知道自己使用的是ubuntu:12.04

	Docker Hub中有两种类型的仓库:用户仓库(user repository) 和顶层仓库(top-level repository).用户仓库的镜像都是由Docker用户创建的,而顶层仓库则是由Docker内部的人员来管理的
	用户仓库的命名由用户名和仓库名两部分组成,如jamtur01/puppet.
		用户名: jamtur01
		仓库名: puppet
	顶层仓库只包含仓库名部分,如ubuntu仓库.顶层仓库由Docker公司和由选定的能提供优质基础镜像的厂商(如Fedora团队提供了fedora镜像)管理.用户可以基于这些基础镜像构建自己的镜像.用户贡献的镜像都是由Docker社区用户提供的,这些镜像并没有经过Docker公司的确认和验证,在使用这些镜像时需要自己承担相应的风险.



3.拉取镜像
	
	用docker run 命令从镜像像启动一个容器,如果镜像不再本地,Docker会先从Docker Hub下载该镜像.如果么既有指定具体的镜像标签.那么
Docker 会自动下载latest标签的镜像
	docker run -t -i --name next_containor ubuntu /bin/bash    ==>docker run和默认的latest标签

	
	通过docker pull 命令自己预先拉取镜像到本地 使用docker pull命令可以节省从一个镜像启动一个容器所需要的时间.
	
	docker pull fedora          ===>拉取fedora镜像

	docker images fedora        ===>查看fedora镜像
	
	docker pull fedora:20       ===>拉取带标签的fedora镜像


4.查找镜像
	docker search puppet       ===>查找镜像
	也可以在Docker Hub网站上在线查找可用镜像   上面的命令在Docker Hub上查找所有的puppet的镜像.这条命令会完成镜像的查找的工作,并返回如下信息:
	仓库名
	镜像描述
	用户评价(Stars) ----反应出一个镜像的受欢迎程度
	是否官方(Official) ----由上游开发者管理的镜像(如fedora镜像由Fedora团队管理)
	自动构建(Autonated)----表示这个镜像是由Docker Hub的自动构建爱呢(Automated Build)流程创建的
	

	docker pull macadmins/puppetmaster   ===>拉取macadmins/puppetmaster 镜像 这条命令将下载macadmins/puppetmaster镜像到本地(这个镜像预装了Puppet master).

	docker run -i -t  macadmins/puppetmaster  /bin/bash    ===>从Puppet master镜像创建一个容器

我们以交互式的方式启动了该容器,并且在运行了Rash shell.在进入容器shell之后,我们运行了Facter(Puppet的主机探测应用).它也是预定义安装在镜像之内的.最后,在容器中运行puppet程序以验证Puppet是否安装正常,它也是在预安装在镜像之内的.



5.构建镜像
	构建Docker镜像有以下两种方法
		1.使用docker commit 命令
		2.docker build命令和Dockerfile文件

并不推荐使用docker commit命令,而使用更灵活,更强大的Dockerfile来构建Docker镜像:一般来说我们不是真正创建新镜像,而是基于一个已有的基础镜像,如ubuntu和fedora等,构建镜像而已.

	5.1创建Docker Hub帐号
		构建镜像中很重要的一环就是如何共享和发布镜像,可以将镜像推送到Docker Hub或者用户自己私有的Registry中
		docker login      ===>登录到Docker Hub
	注意:个人认证信息将会保存到$HOME/.dockercfg文件中

	5.2用Docker的commit命令创建镜像
		创建Docker镜像的第一种方法是使用docker commit命令,类似往版本控制系统里提交变更,我们先创建一个容器,并在容器里做出修改,就像修改代码一样,最后再将修改提交为一个新镜像
		docker rubn -i -t ubuntu /bin/bash     ===>创建一个要进行修改的定制容器
		接下来,在容器中安装Apache
		
		apt-get -yq update
		apt-get -y install apache2       ====>安装apache软件包

	我们启动了一个容器,并在里面安装了Apache,这将作为一个Web服务器来运行,所以把当前状态保存下来,完成此项工程,需要首先exit命令从容器中退出,之后在运行docker commit命令.
		
		docker commit 4aab3ce3cb75  rnjack/apche2   ====>提交定制容器
	docker commit命令中,指定了要提交的修改过的容器的ID(可以通过docker ps -l -q命令来得到刚创建的容器ID),以及一个目标镜像仓库和镜像名,这里是rnjack/apache2.需要注意的是,docker commit提交的只是创建容器的镜像与容器当前状态之间有差异的部分,这使得该跟新非常轻量.

		docker commit -m="A new custom image" --author=="rnjack" 4aab3ce3cb75  rnjack/apche2:webserver   ====>提交定制容器 带有详细信息.
	这条命令里,我们指定了更多信息选项,首先 -m :用来指定新创建的镜像的提交信息 --author选项,用来列出该镜像的作者信息 接着指定了要提交的容器的ID,最后的rnjack/apache2指定了镜像的用户名和仓库名,并为该镜像增加了一个webserver 标签
	
	
	5.3使用Dockerfile构建镜像
		推荐使用被称为Dockerfile的定义文件和docker build 命令来构建镜像.Dockerfile使用基本的基于DSL语法的指令来构建Docker镜像,之后使用docker build命令基于该Dokerfile中的指令来构建一个新的镜像.
	
		第一个Dockerfile
		创建一个目录并在里面创建初始的Dockerfile.创建一个简单Web服务器的Docker镜像.创建一个示例仓库
			make static_web 
			cd static_web
			touch Dockerfile
		我们创建了一个名为static_web的目录来保存Dockerfile,这个目录就是构建环境(build environment),Docker则称此环境为上下文(context)或者构建上下文(build context) Docker会在构建镜像时将构建上下文和该上下文中的文件和目录上传到Docker守护进程.这样Docker守护进程就能直接访问你想在在镜像中存储的任何代码,文件或者其它数据

		第一个Dockerfile:
		#Version:0.0.1
		From ubuntu:14.04
		MAINTAINER Rnjack "rnjack998@gmail.com"
		RUN apt-get update
		RUN apt-get install -y nginx
		RUN  echo 'Hi,I am in your container' > /user/share/nginx/html/index.html
		EXPOSE 80
	该Dockerfile 由一系列指令和参数组成.每条指令名,如From,都必须为大写字母且后面需要跟一个参数:FROM ubuntu14.04.Dockerfile中的指令会按顺序从上到下执行,所以应该根据需要合理安排指令的顺序.每条指令都会创建一个新的镜像层对镜像进行提交.Docker大体上按照如写流程执行Dockerfile中的指令.
		
		Dockerfile从基础镜像运行一个容器
		执行一条指令,对容器做出修改
		执行类似docker commit的操作,提交一个新的镜像层
		Docker再基于刚提交的镜像运行一个新容器
		执行Dockerfile中的下一条指令,直到所有指令都执行完毕

	从上面可以看出,如果Dockerfile由于某些原因(如耨条指令失败了)没有正常结束,那么将得到一个可以使用的镜像.这对调试非常有帮助:可以基于该镜像运行一个具有交互功能的容器,使用最后创建的镜像对为什么你的指令失败进行调试 Dockerfile也支持注释,以#开头的行都会被认为是注释.
	
	每个Dockerfile的第一条指令都应该是FROM.FROM指令指定了一个已经存在的镜像,后续指令将基于该镜像进行.这个镜像被称为基础镜像(base image) 在Dockerfile示例中,我们指定了ubuntu:14.04作为镜像的基础镜像.基于这个Dockerfile构建的新镜像将以Ubuntu14.04作为操作系统为基础.在运行一个容器时,必须要指明是基于那个基础惊镜像进行构建

	接着指定了MAINTAINER指令,这条指令告诉Docker该镜像的作者是谁,以及作者的电子邮件地址,这有助于标识镜像的所有者和联系方式

	在这些指令之后,指定了三条RUN指令.RUN指令会在当前镜像中运行指定的命令,在这个例子中,我们通过RUN指令更新了已经安装APT仓库,安装了nginx包.之后创建了/usr/share/nginx/html/index.html文件,该文件中有一些简单的文本示例文本.每条RUN指令都会创建一个新的镜像层,如果该指令执行成功,就会将此镜像提交,之后继续执行Dockerfile中的下一条指令
	默认情况下,RUN指令会在shell里使用命令包装器/bin/sh -c 来执行 如果在一个不支持shell的平台上运行或者不希望在shell中运行(比如避免shell字符串篡改),也可以使用exec格式的RUN指令
	RUN {"apt-get","install","-y","nginx"}          ===>exec格式的RUN指令
	这种方式中,我们使用了一个数组来指定要运行的命令和传递给该命令的每个参数
	
	设置EXPOSE指令,这条指令告诉Docker 该容器内的应用程序将会使用容器的指定端口,这并不意味着可以自动访问任意容器运行中的服务端口,出入安全原因,Docker并不会自动打开端口名,而是在使用docker run 运行容器时来指定要打开哪些端口,可以指定多个EXPOSE指令来向外部公开多个端口


	5.4 基于Dockerfile构建新镜像

		执行docker build命令时,Dockerfile中的所有指令都会被执行并且提交,并且在该命令成功结束后返回一个新镜像.运行Dockerfile
	
		cd static_web
		docker build -t="rnjack/static_web" ,

		使用docker build命令来构建新镜像,-t选项为新镜像设置了仓库和名称,也可以该构建镜像的过程中设置一个标签,其使用方法为"镜像名:标签"
		docker buil -t="rnjack/static_web:version01"  ===>在构建时为镜像设置标签
	提示:如果没有制定任何标签,Docker将会自动为镜像设置一个latest标签

	上面命令最后的.告诉Docker到本地目录中去找Dockerfile文件.也可以指定一个Git仓库的源地址来指定Dockerfile的位置
	
	docker build -t="rnjack/static_web:version01" git@github.com:rnjack/docker-static_web
	这里Docker假设在这个Git仓库的根目录下存在Dockerfile文件 将构建上下文上传到Docker守护进程
	Sending build context to Docker daemon 2.048 kB    如果在构建上下文的根目录下存在以.dockerignore命令的文件的话,该文件内容会按
行进行分割,每一行都是一条文件爱呢过滤匹配模式.这非常像.gitignore文件爱呢,该文件用来设置哪些文件不会被上到构建上下文中去,该文件中模式的匹配规范采用了Go语言中的filepath.
	
	之后,可以看到Dockerfile中的每条指令会被顺序执行,而且作为构建过程的最终结果,返回了新的镜像的ID,构建的每一步及其对应指令都会独立运行,并且在输出最终镜像ID之前,Docker会提交每一步的构建结果

	5.5指令失败时怎样 
		管理失败的指令,用docker run命令来基于这次构建的目前为止已经成功的最后一步创建的一个容器
		基于最后的成功步骤创建新容器
		再到这个容器中运行出错位置的指令,修改正确的指令
		退出容器,修改Dockerfile文件,之后在尝试进行构建
	
	5.6 Dockerfile 和构建缓存
		由于每一步构建过程都会将结果提交为镜像,所以Docker的构建镜像过程就非常聪明.它会将之气拿的镜像看作缓存
		docker build --no-cache -t="rnjack01/static_web:version01" . ===>忽略Dockerfile的构建缓存

	
	5.7 基于构建缓存的Dockerfile模板
		构建缓存带来的一个好处就是,可以实现简单的Dockerfile模板(比如在Dockerfile文件顶部增加包仓库或者更新包,从而尽可能确保缓存命中).一般都会在自己的Dockerfile文件顶部使用相同的指令集模板,比如对Ubuntu
		Ubuntu系统的Dockerfile模板
	

		FROM ubuntu:14.04
		MAINTAINER RNjack  "rnjack998@gmail.com"
		ENV REFRESHED_AT 2016-10-16
		RUN apt-get -qq update
		
		首先通过FROM指令为新镜像设置了一个基础镜像ubuntu:14.04,接着使用MAINTAINER指令添加自己的详细联系信息,使用ENV来设置环境变量.我们通过ENV指令来设置了一个名为REFRESHED_AT的环境变量,用来表明该镜像模板最后的更新时间.最后使用RUN 指令运行 apt-get -qq update命令.该指令时将会刷新APT包的缓存,用来确保我们能将要安装的每个软件包都更新到最新版本
		
		Fedora Dockerfile模板
		
		FROM fedora:20
		MAINTAINER RNjack 'rnjack998@gmail.com'
		ENV REFRESHED_AT 2016-10-16
		RUN yum -y -q upgrade
	
	5.8 查看新镜像
		
		docker images rnjack/static_web     ===>列出新的Docker镜像
		
		深入探求镜像是如何构建出来的,可以使用docker history命令
		docker history 22d47c8cb6e5         ===>使用docker history命令
		
		从返回的结果可以看到新构建的rnjack/static_web镜像的每一层,以及创建这些层的Dockerfile指令

	5.9从新镜像启动容器
		
		基于新构建的镜像启动一个新容器,来检查以下我们的构建工作是否一切正常
	
		docker run -d -p 80 --name static_web rnjack/static_web:version01 nginx -g "daemon off;"
	
	-d告诉Docker以分离(detached)的方式在后台运行.这种方式非常适合运行类似Nginx守护进程这样需要长时间运行的进程.我们需要在容器中运行的命令:nginx -g "daemon off;" 这将以前台运行的方式启动Nginx来作为我们的Web服务器
	-p 标志,该标志来控制Docker在运行时应该公开哪些网络端口给外部(宿主机). 运行一个容器时,Docker可以通过两种方法来在宿主机上分配端口.
	
	Docker可以在宿主机上随机选择一个位于49153~65535的一个比较大的端口号来映射到容器中的80端口上.
	
	可以在Docker宿主机中指定一个具体端口号来映射到容器中的80端口上.这将在Docker宿主机上随机打开一个端口,这个端口会连接到容器的80端口上.使用docker ps 命令来查看容器的端口分配情况				

	docker ps -l         ===>查看Docker端口映射情况
	可以看到,容器中的80端口被映射到宿主机的49154上,也可以通过docker port来查看容器的端口映射情况

	docker port 675b84bb50c0 80  ===>docker port命令
	指定了想要查看映射情况的容器ID和容器的端口号,这里是80.该命令返回了宿主机中映射的端口 即49154 -p选项可以指定将容器中的端口映射到Docker宿主机的某一特定端口上

	docker run -d -p 80:80  --name static_web rnjack/static_web:version01 nginx -g "daemon off;"  ===>通过-p选项映射到的特定端口


	docker run -d -p 8080:80  --name static_web rnjack/static_web:version01 nginx -g "daemon off;"  ===>通过-p选项映射到的特定端口
	绑定到特定的网络接口
	docker run -d -p 127.0.0.1:80:80 --name static_web rnjack/static_web:version01 nginx -g "daemon off;"	

	绑定到特定的网络接口的随机端口
	docker run -d -p 127.0.0.1::80  --name static_web rnjack/static_web:version01 nginx -g "daemon off;"
	上面指令没有指定具体要绑定的宿主机上的端口号,只指定了以个IP地址127.0.0.1,这时我们可以使用docker inspect或者 docker port命令来查看容器内的80端口具体被绑定到了宿主机上的哪个端口上.


	Docker 还提供了一个简单的方式,即 -P参数,该参数可以用来对外公开在Dockerfile中的EXPOSE指令中设置的所有端口

	docker run -d -P  --name static_web rnjack/static_web:version01 nginx -g "daemon off;" 该命令将容器内的80端口对本地宿主机公开,并且绑定到宿主机的一个随机端口上.该命令将用来构建该镜像的Dockerfile文件中的EXPOSE指令指定的其它端口也一并公开.  

	5.10 Dockerfile指令
		Dockerfile中可以使用的指令,如RUN和EXPOSE.实际上Dockerfile中放入很多其它指令,这些指令包括CMD,ENTRYPOINT,ADD,COPY,VOLUME,WORKDIR,USER,ONBUILD和ENV等.
		a.CMD
	CMD指令用于指定了一个容器启动时要运行的命令.这有点儿类似于RUN指令,只是RUN指令是指定镜像被构建时要运行的命令,而CMD是指定容器被启动时要运行的命令.这和使用docker run命令启动容器时指定要运行的命令非常类似
	
	docker run -i -t rnajck/static_web /bin/true    ====>指定运行的特定命令
	在Dockerfile中使用代码 CMD指令是等效的
	CMD["/bin/true"]     ===>使用CMD指令
	当然也可以为要运行的命令指定参数
	
	CMD ["/bin/bash","-l"]              ===>给CMD指令传递参数   这里我们将-l标志传递给了/bin/bash命令

	要运行的命令是存放在一个数组结构中的.这将告诉Docker按指定的原样来运行该命令.当然也可以不使用数组样指定CMD命令.这时Docker会在指定的命令加上/bin/sh -c.这在执行该命令的时候可能会导致意料之外的行为.所以Docker推荐一直使用以数组语法来设置要执行的命令.
	
	使用docker run 命令可以覆盖CMD指令.要在Dockerfile里指定了CMD指令.同时要在docker run命令中也指定了要运行的命令,命令行中指定的命令会覆盖Dockerfile中的CMD指令  ---深刻理解CMD和ENTERPOINT之间的相互作用关系也非常重要.

	CMD ["/bin/bash"]     ===>覆盖Dockerfile文件中的CMD指令
	
	docker run -t -i  rnjack/test       ===>构建新的镜像 ,开始运行 会直接启动bash (CMD命令)  
	
































































		













































































































































	
	
































































































































 
