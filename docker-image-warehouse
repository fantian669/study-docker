	使用Docker镜像和仓库

创建一个最基本的Docker容器
	docker run -i -t --name another_container  ubuntu /bin/bash 
这条命令将会启动一个新的名为anthor_container 的容器,这个容器基于ubuntu镜像并且会启动Bash shell.

本章中我们将探讨Docker镜像:用来启动容器的基石:学习内容  什么是镜像,如何对镜像进行管理,如何修改镜像,以及如何创建,存储和共享自己创建的镜像,还会介绍用来存储镜像的仓库和用来存储仓库的Registry.



1.什么是Docker镜像
	Docker镜像是由文件系统叠加而成的.最底端是一个引导文件系统,即bootfs,这很像典型的Linux/Unix的引导文件系统.Docker用户几乎永远不会和引导文件文件系统有什么交互,实际上当一个容器启动后,它就会被移动内存中,而引导文件系统则会被卸载(unmount).以留更多内存供initd磁盘镜像使用.

	Docker镜像的第二层是root文件系统rootfs,它位于引导文件系统之上.rootfs可以是一种或多种操作系统(如Debian或者Ubuntu文件系统)在传统的Linux引导过程中,root文件系统会最先以只读的方式加载,当引导结束并完成了完整性检查之后,才会被切换为读写模式 但是在Docker里,root文件系统永远是只读状态,并且Docker利用联合加载(union mount)技术又会在root文件系统层上加载更多的只读文件系统.联合加载指的是一次同时加载多个文件系统,但是在外面只能看到一个文件系统.联合加载会将各层文件系统叠加到一起,这样最终文件系统包含所有底层的文件和目录.

	Docker将这样的文件系统称为镜像,一个镜像可以放到另一个镜像的顶部,位于下面的镜像称为parent image ,最底部的镜像称为基础镜像 base image. 当从一个镜像启动时,Docker会在该镜像的顶层加载一个读写文件系统.


	可写容器
	
	镜像 :加入Apacher
	镜像 :加入emacs
	基础镜像: ubuntu
	引导文件系统
		容器组 命名空间 设备映射
	内核

写时复制(copy and write):初始对写层是空的,当文件系统发生变化是,这些变化都会应用到读写层,比如:想修改一个文件,这个文件爱呢首先会从该读写层虾米拿的只读层复写到该读写层.该文件的只读版本依然存在,但已经被读写层的文件副本所隐藏


当创建一个新的容器时,Docker会构建一个镜像栈,并在栈的最顶端添加一个读写层,这个对写层加上其下面的镜像层以及一些配置数据,就构成一个容器



2.列出镜像

	docker images  ===>列出Docker镜像

本地镜像都保存在Docker宿主机的/var/lib/docker目录霞.每个镜像都保存在Docker所采用的存储驱动目录下面如 aufs或者 devicemapper 也可以在/var/lib/docker/containers目录霞看到所有容器
镜像从仓库下载写来.镜像保存在仓库中,而仓库存在与Registry中,而默认的Registry是由Docker公司运行的公共Registry服务,即Docker Hub	

	docker pull ubuntu     ===>拉取Ubuntu镜像
	使用docker pull ubuntu命令拉取Ubuntu仓库中的所有内容
注意:我们虽然称其为Ubuntu操作系统,但实际上它并不是一个完整的操作系统,它只是一个裁剪版,只包含最低限度的支持系运行的组件,为了区分同一个仓库中的不同镜像,Docker提供了一种被称为标签(tag)的功能,每个镜像在列出时都带有一个标签.我们可以通过仓库名后面加一个冒号和标签名来指定该仓库的某以镜像

	docker run -i -t --name new_container ubuntu:12.04 /bin/bash  ==>运行一个带标签的Docker镜像  












































































 
